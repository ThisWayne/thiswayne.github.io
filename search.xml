<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[The Effective Engineer閱讀筆記]]></title>
    <url>%2Fposts%2Fbook-note-the-effective-engineer%2F</url>
    <content type="text"><![CDATA[個人的全書總結，整本書圍繞著有很多事情要做，在選擇不同的事情上，選擇上應該多著重在長遠的、有效的來當戰略，而不是與之相反的在短期的、只著重在效率上的戰術。這裡的有效（effective）與策略（strategy）指的是長遠來看效益很高、會隨時間有著槓桿（leverage）成長的。這裡的有效率（efficiency）與戰術（tactic）指的是短期的、以快速為目的達成目標。基本上高手講的都一樣，不要用戰術上的勤勞掩蓋戰略上的懶惰，好的戰術可以打贏一場戰役，好的戰略可以打贏一場戰爭。 一個月裡每天花一小時帶新人可能很划算一般來說一年的工時大概會是18002200小時，一個月工作天數算22天，每天一小時也就是22小時，算下來只花了一年可能只有1%1.2%的工時。新人的成長，比方說學會怎麼更好的debug，可以讓新人之後都能省去很多時間，跟沒學會debug比起來，越早學會越早開始有更好且更多的產出，長遠來看會是很划算的投資。 如何增加產值？一般來說，在單位時間內產出的價值能增加的方法有三種： 降低完成一項活動的時間 增加一項活動的輸出 選擇做其他更有價值的事情 也就是三種問題： 怎麼樣可以在更短的時間內完成一項活動？ 怎麼樣可以讓完成的一項活動更有價值？ 有沒有其他事情做了會產出更多價值？ 如何避免拖延？IF-THEN方法：如果吃完飯，然後就看教材；如果怎麼樣，然後就怎麼樣，自動的去執行，不要留有意識的來做選擇 盡早且頻繁的取得回饋越晚越不頻繁的取得回饋，路走偏了越晚修正就越浪費資源 有測量數據，有明確的改進理由與成效If you can&#39;t measure it, you can&#39;t improve it. 選出好的測量數據當改善的指標非常重要，比方說Google測量使用者停留在搜尋結果的情況來判斷搜尋的品質 測量生產力 &gt; 工時 頁面停留時間（long-click） vs. 點擊率點擊率高有些情況也可能是使用者在找功能，而long-click以Google搜尋來說，最好的情況是使用者點第一個連結，沒有再回來搜尋結果頁面 平均回應時間 vs. 95th or 99th 百分比的回應時間選擇不同的數據當指標，要改善的地方會不同，想要達成的目標可能也不一樣 盡可能的把裝況、發生什麼事情等等的所有事情的都顯示出來要像開飛機會有一堆儀表板可以看，要知道自己的服務的狀況，以免出事情或是要擴展等等都不知道自己服務的情況 專案延時會因為讓目標要達成的時間去修改了預估的時間 把task拆成小的task 估時要根據要花多久時間完成而不是希望多久完成 估時應該像是機率，而不是總是出現最好的情況 讓實際要做該項task的人估時 小心錨定效應，估計某一個task最快完成時間後其他東西也用前面錨定的時間繼續估計 找多種方式去估時同一個task 小心人月估算，人多不一定快 根據歷史的估時，來驗證現在的估時 研究東西可以研究無限久，考慮給定一個時間來看有什麼樣的結果來竟可能的做最好的選擇 讓其他人chanllenge估時 給定明確的目標與milestone比方說，降低第95th百分比的延遲時間到500ms以內 比較模糊不清比較不好的，在一個月內重寫某某程式 把時程估計列入專案的計畫 可以決定在一個時間點是否可以有哪些功能，如果時間點不行，則討論該時間點應該要先有哪些重要的功能 時程規劃要有緩衝，要把假期、生病等等的時間也估算進來 先把有風險的工作做掉，先做簡單的可能會有進度很快的假象 只有在很確定加班趕得上時程的時候才使用加班 code review與測試不一定是要做與不做的選擇可以只在很重要的地方做code review跟測試，資源有限的情況下不重要的就先跳過 好的batch應該要是重複執行也會得到一樣的結果好的batch即使執行時某些地方壞掉了需要調整，調整後可以再執行一次仍然得到同樣的結果 或是至少可以retry 計畫一個失敗了以後仍然能很快的復原的模式失敗了可以很快復原，會比較有信心且大膽的前進 比方說用版本控制系統，寫錯了就回上一版。上線的系統仍然有bug，能很快的回上一個沒有bug的版本 公司的成功會很大的影響個人的成功Andy Rachleff: You get more credit than you deserve for being part of a successful company, and less credit than you deserve for being part of an unsuccessful company 如何循序的改善面試流程 跟組員一同找出將來的組員要有哪些重要的特質 週期性的回顧目前的流程是否有效 設計不同難度的問題來看面試者的程度 目的是要多了解面試者，可以在一些地方給提示，或換問題，不要在一些地方卡太久 週期性的找其他組員一起參與面試，看有沒有流程要改善 入職訓練 定出目標 找出該怎麼達成目標 可能會有mentorship，可能會有onboarding talk介紹工具等等，可能回有個適合的小task來進入專案，看目標是什麼 不要讓一件事情只有一個人能做，share ownership of code真的有事情急需要救火的時候，萬一能做的人手邊也沒電腦就完了，或是請假，人事變動等等的 回顧工作，蒐集智慧下次怎麼樣做更好，分享給不同的團隊以免重複採坑 對於前公司工程的文化上哪一點喜歡與哪一點不喜歡可以知道彼此適不適合，也可以知道哪些東西會讓員工不喜歡]]></content>
      <tags>
        <tag>Software Development</tag>
        <tag>Reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C#的Async & Await筆記(2)]]></title>
    <url>%2Fposts%2Fcsharp-async-await-note-2%2F</url>
    <content type="text"><![CDATA[既上一篇的一些觀念，來寫一些程式來實際驗證一下C#不同類型的專案上async/await跑起來會怎麼運作，執行緒會怎麼樣調用。 TL;DR，執行緒調用方式上一篇C#的Async &amp; Await筆記有較多的概念 這一篇的程式碼在這csharp-lab 一遇到await，執行緒不會馬上跳回到caller端，執行緒還是會往呼叫的methodAsync執行，直到最底層回傳一個Task，才開始依序跳回caller端，但如果Task已經是完成的狀態，則會省去原await機制，用原執行緒繼續執行。 一般Task不是已經完成的狀態下，遇到await，會優先看「當前」執行緒上有沒有SynchronizationContext，有則await後續的code會是原執行緒main thread來執行；沒有則await後續的code由thread pool裡面的執行緒執行。 一般Task不是已經完成的狀態下，遇到await加上ConfigureAwait(false)，則await後續的code會由thread pool裡面的執行緒執行。 執行環境硬體 CPU：4 * Intel i7-6600U 2.6GHz RAM： 16.0 GB 系統類型： x64 作業系統：Windows 10 測試的project類型與target framework Console App： .NET Framework 4.6.1 WPF： .NET Framework 4.6.1 .NET Framework Web API： .NET Framework 4.6.1 .NET Core Web API： .NET Core 2.1.1 測試方式 寫了一個library project TestClassLibrary裡面放一個AsyncAwaitTestClass.cs，所有要跑的code都寫在裡面，可以給.NET Framework和.NET Core參照與使用 下面跑測試會個別跑，會先註解掉其他測試來讓執行測試的起始情況一致 測試有寫的四種project類型，測試上不一樣的地方主要是WPF的main thread有SynchronizationContext，其他測試上的差別只有起始thread像WPF、Console App是main thread，還是像web server是調用worker thread的差別 因為有無SynchronizationContext，基本上只會有兩種較不一樣的執行結果，下面只寫出WPF和.NET Core的結果，想執行看看都還是可以抓回去玩玩看 印出測試訊息用Debug.WriteLine寫在output讓不同的project類型都會在同一個地方印出來，會透過執行AsyncAwaitTestClass.PrintInfos印出執行的當下有多少worker threads、iocp threads、total threads，印出當下執行緒的SynchronizationContext、ManagedThreadId、IsThreadPoolThread。 C#12345678910111213141516private void PrintInfos()&#123; ThreadPool.GetMaxThreads(out int maxWorkerThreads, out int maxCompletionPortThreads); ThreadPool.GetAvailableThreads(out int workerThreads, out int completionPortThreads); Debug.WriteLine( " -- Worker threads: &#123;0&#125;, Completion port threads: &#123;1&#125;, Total threads: &#123;2&#125;", maxWorkerThreads - workerThreads, maxCompletionPortThreads - completionPortThreads, Process.GetCurrentProcess().Threads.Count ); Debug.WriteLine( $" SynchronizationContext: &#123;SynchronizationContext.Current&#125;\n" + $" ManagedThreadId: &#123;Thread.CurrentThread.ManagedThreadId&#125;\n" + $" IsThreadPoolThread: &#123;Thread.CurrentThread.IsThreadPoolThread&#125;" );&#125; 測試一：執行續一遇到await就返回呼叫端？(1)程式碼C#1234567891011121314151617private async Task RunTest1()&#123; Debug.WriteLine("===== Test 1 ====="); Debug.WriteLine("1. === Before ReturnFinishedTaskAsync ==="); PrintInfos(); await ReturnFinishedTaskAsync(); Debug.WriteLine("===== Test 1 End =====");&#125;private async Task&lt;int&gt; ReturnFinishedTaskAsync()&#123; Debug.WriteLine("2. === Begin MethodWithFinishedTask ==="); PrintInfos(); return await Task.FromResult&lt;int&gt;(0);&#125; (1)執行結果123456789101112131415161718===== Current Thread Info (in TestStart method) ===== -- Worker threads: 0, Completion port threads: 0, Total threads: 10 SynchronizationContext: ManagedThreadId: 1 IsThreadPoolThread: False===== Test Start ========== Test 1 =====1. === Before ReturnFinishedTaskAsync === -- Worker threads: 0, Completion port threads: 0, Total threads: 10 SynchronizationContext: ManagedThreadId: 1 IsThreadPoolThread: False2. === Begin MethodWithFinishedTask === -- Worker threads: 0, Completion port threads: 0, Total threads: 10 SynchronizationContext: ManagedThreadId: 1 IsThreadPoolThread: False===== Test 1 End ===== 不是一看到await，當前thread就跳回到caller，await裡面的code還是會先由當前thread執行，會直到執行到底層傳回task才「通常」開始一層一層返回caller。 可以在output上看到RunTest1的1.跟ReturnFinishedTaskAsync裡面的2.都是同一個thread ID，四種project結果都一樣。其實想成下面這樣，程式是一樣的，應該就直覺async method裡面也會是同一個thread先執行。 C#1234567891011private async Task RunTest1()&#123; Debug.WriteLine("===== Test 1 ====="); Debug.WriteLine("1. === Before ReturnFinishedTaskAsync ==="); PrintInfos(); var task = ReturnFinishedTaskAsync(); // 這裡把await分開來寫 await task; Debug.WriteLine("===== Test 1 End =====");&#125; 測試二：await加不加ConfigureAwait(false)會發生什麼事，後續執行緒是？(2.1)不加ConfigureAwait(false)(2.1)程式碼C#123456789101112private async Task RunTest2_1()&#123; Debug.WriteLine("===== Test 2.1 ====="); Debug.WriteLine("1. === Before httpClient.GetStringAsync ==="); PrintInfos(); await httpClient.GetStringAsync(url); // without ConfigureAwait(false) Debug.WriteLine("2. === After httpClient.GetStringAsync ==="); PrintInfos();&#125; (2.1)執行結果(2.1)WPF執行httpClient.GetStringAsync前後的code會是一樣的thread 12345678910111213141516===== Current Thread Info (in TestStart method) ===== -- Worker threads: 0, Completion port threads: 0, Total threads: 19 SynchronizationContext: System.Windows.Threading.DispatcherSynchronizationContext ManagedThreadId: 1 IsThreadPoolThread: False===== Test 2.1 =====1. === Before httpClient.GetStringAsync === -- Worker threads: 0, Completion port threads: 0, Total threads: 19 SynchronizationContext: System.Windows.Threading.DispatcherSynchronizationContext ManagedThreadId: 1 IsThreadPoolThread: False2. === After httpClient.GetStringAsync === -- Worker threads: 0, Completion port threads: 0, Total threads: 28 SynchronizationContext: System.Windows.Threading.DispatcherSynchronizationContext ManagedThreadId: 1 IsThreadPoolThread: False (2.1).NET Core Web API執行httpClient.GetStringAsync前後的code是不一樣的thread，後面是iocp thread 12345678910111213141516===== Current Thread Info (in TestStart method) ===== -- Worker threads: 1, Completion port threads: 0, Total threads: 23 SynchronizationContext: ManagedThreadId: 16 IsThreadPoolThread: True===== Test 2.1 =====1. === Before httpClient.GetStringAsync === -- Worker threads: 1, Completion port threads: 0, Total threads: 23 SynchronizationContext: ManagedThreadId: 16 IsThreadPoolThread: True2. === After httpClient.GetStringAsync === -- Worker threads: 0, Completion port threads: 1, Total threads: 24 SynchronizationContext: ManagedThreadId: 22 IsThreadPoolThread: True (2.2)加ConfigureAwait(false)(2.2)程式碼C#123456789101112private async Task RunTest2_2()&#123; Debug.WriteLine("===== Test 2.2 ====="); Debug.WriteLine("1. === Before httpClient.GetStringAsync ==="); PrintInfos(); await httpClient.GetStringAsync(url).ConfigureAwait(false); // with ConfigureAwait(false) Debug.WriteLine("2. === After httpClient.GetStringAsync ConfigureAwait(false) ==="); PrintInfos(); // 1. and 2. would be different thread ID&#125; (2.2)執行結果(2.2)WPF12345678910111213141516===== Current Thread Info (in TestStart method) ===== -- Worker threads: 0, Completion port threads: 0, Total threads: 14 SynchronizationContext: System.Windows.Threading.DispatcherSynchronizationContext ManagedThreadId: 1 IsThreadPoolThread: False===== Test 2.2 =====1. === Before httpClient.GetStringAsync === -- Worker threads: 0, Completion port threads: 0, Total threads: 14 SynchronizationContext: System.Windows.Threading.DispatcherSynchronizationContext ManagedThreadId: 1 IsThreadPoolThread: False2. === After httpClient.GetStringAsync ConfigureAwait(false) === -- Worker threads: 0, Completion port threads: 1, Total threads: 26 SynchronizationContext: ManagedThreadId: 10 IsThreadPoolThread: True (2.2).NET Core Web API12345678910111213141516===== Current Thread Info (in TestStart method) ===== -- Worker threads: 1, Completion port threads: 0, Total threads: 28 SynchronizationContext: ManagedThreadId: 10 IsThreadPoolThread: True===== Test 2.2 =====1. === Before httpClient.GetStringAsync === -- Worker threads: 1, Completion port threads: 0, Total threads: 28 SynchronizationContext: ManagedThreadId: 10 IsThreadPoolThread: True2. === After httpClient.GetStringAsync ConfigureAwait(false) === -- Worker threads: 0, Completion port threads: 1, Total threads: 30 SynchronizationContext: ManagedThreadId: 12 IsThreadPoolThread: True (2.3)加ConfigureAwait(false)後面一定會是iocp thread？(2.3)程式碼C#123456789101112private async Task RunTest2_3()&#123; Debug.WriteLine("===== Test 2.3 ====="); Debug.WriteLine("1. === Before ReturnFinishedTaskAsync ==="); PrintInfos(); await ReturnFinishedTaskAsync().ConfigureAwait(false); // with ConfigureAwait(false) Debug.WriteLine("3. === After ReturnFinishedTaskAsync ConfigureAwait(false) ==="); PrintInfos();&#125; (2.3)執行結果如果跑的不是非同步IO當然不會是iocp thread 如果Task已經是完成的狀態，則會省去原await機制，用原執行緒繼續執行 (2.3)WPF123456789101112131415161718192021===== Current Thread Info (in TestStart method) ===== -- Worker threads: 0, Completion port threads: 0, Total threads: 19 SynchronizationContext: System.Windows.Threading.DispatcherSynchronizationContext ManagedThreadId: 1 IsThreadPoolThread: False===== Test 2.3 =====1. === Before ReturnFinishedTaskAsync === -- Worker threads: 0, Completion port threads: 0, Total threads: 19 SynchronizationContext: System.Windows.Threading.DispatcherSynchronizationContext ManagedThreadId: 1 IsThreadPoolThread: False2. === Begin MethodWithFinishedTask === -- Worker threads: 0, Completion port threads: 0, Total threads: 19 SynchronizationContext: System.Windows.Threading.DispatcherSynchronizationContext ManagedThreadId: 1 IsThreadPoolThread: False3. === After ReturnFinishedTaskAsync ConfigureAwait(false) === -- Worker threads: 0, Completion port threads: 0, Total threads: 19 SynchronizationContext: System.Windows.Threading.DispatcherSynchronizationContext ManagedThreadId: 1 IsThreadPoolThread: False (2.3).NET Core Web API123456789101112131415161718192021===== Current Thread Info (in TestStart method) ===== -- Worker threads: 1, Completion port threads: 0, Total threads: 23 SynchronizationContext: ManagedThreadId: 9 IsThreadPoolThread: True===== Test 2.3 =====1. === Before ReturnFinishedTaskAsync === -- Worker threads: 1, Completion port threads: 0, Total threads: 23 SynchronizationContext: ManagedThreadId: 9 IsThreadPoolThread: True2. === Begin MethodWithFinishedTask === -- Worker threads: 1, Completion port threads: 0, Total threads: 23 SynchronizationContext: ManagedThreadId: 9 IsThreadPoolThread: True3. === After ReturnFinishedTaskAsync ConfigureAwait(false) === -- Worker threads: 1, Completion port threads: 0, Total threads: 23 SynchronizationContext: ManagedThreadId: 9 IsThreadPoolThread: True (2.4)連續兩個await呼叫有加ConfigureAwait(false)(2.4)程式碼C#1234567891011121314151617private async Task RunTest2_4()&#123; Debug.WriteLine("===== Test 2.4 ====="); Debug.WriteLine("1. === Before httpClient.GetStringAsync ==="); PrintInfos(); await httpClient.GetStringAsync(url).ConfigureAwait(false); // with ConfigureAwait(false) Debug.WriteLine("2. === After httpClient.GetStringAsync ConfigureAwait(false) ==="); PrintInfos(); await httpClient.GetStringAsync(url).ConfigureAwait(false); // with ConfigureAwait(false) Debug.WriteLine("3. === After httpClient.GetStringAsync ConfigureAwait(false) ==="); PrintInfos();&#125; (2.4)執行結果這邊訊息的2.跟3.有可能會是同一個iocp thread，畢竟我都對同一個URL發HTTP GET，有可能是cache導致Task很快就完成了，或是真的第二個await真的接手的thread跟第一個一樣 (2.4)WPF123456789101112131415161718192021===== Current Thread Info (in TestStart method) ===== -- Worker threads: 0, Completion port threads: 0, Total threads: 19 SynchronizationContext: System.Windows.Threading.DispatcherSynchronizationContext ManagedThreadId: 1 IsThreadPoolThread: False===== Test 2.4 =====1. === Before httpClient.GetStringAsync === -- Worker threads: 0, Completion port threads: 0, Total threads: 19 SynchronizationContext: System.Windows.Threading.DispatcherSynchronizationContext ManagedThreadId: 1 IsThreadPoolThread: False2. === After httpClient.GetStringAsync ConfigureAwait(false) === -- Worker threads: 0, Completion port threads: 1, Total threads: 28 SynchronizationContext: ManagedThreadId: 10 IsThreadPoolThread: True3. === After httpClient.GetStringAsync ConfigureAwait(false) === -- Worker threads: 0, Completion port threads: 1, Total threads: 28 SynchronizationContext: ManagedThreadId: 12 IsThreadPoolThread: True (2.4).NET Core Web API123456789101112131415161718192021===== Current Thread Info (in TestStart method) ===== -- Worker threads: 1, Completion port threads: 0, Total threads: 29 SynchronizationContext: ManagedThreadId: 15 IsThreadPoolThread: True===== Test 2.4 =====1. === Before httpClient.GetStringAsync === -- Worker threads: 1, Completion port threads: 0, Total threads: 29 SynchronizationContext: ManagedThreadId: 15 IsThreadPoolThread: True2. === After httpClient.GetStringAsync ConfigureAwait(false) === -- Worker threads: 0, Completion port threads: 1, Total threads: 30 SynchronizationContext: ManagedThreadId: 20 IsThreadPoolThread: True3. === After httpClient.GetStringAsync ConfigureAwait(false) === -- Worker threads: 0, Completion port threads: 1, Total threads: 30 SynchronizationContext: ManagedThreadId: 17 IsThreadPoolThread: True (2.5)先呼叫一個await有加ConfigureAwait(false)，然後再呼叫一個await不加ConfigureAwait(false)？(2.5)程式碼C#1234567891011121314151617private async Task RunTest2_5()&#123; Debug.WriteLine("===== Test 2.5 ====="); Debug.WriteLine("1. === Before httpClient.GetStringAsync ==="); PrintInfos(); await httpClient.GetStringAsync(url).ConfigureAwait(false); // with ConfigureAwait(false) Debug.WriteLine("2. === After httpClient.GetStringAsync ConfigureAwait(false) ==="); PrintInfos(); await httpClient.GetStringAsync(url); // without ConfigureAwait(false) Debug.WriteLine("3. === After httpClient.GetStringAsync ==="); PrintInfos();&#125; (2.5)執行結果WPF的第一個httpClient.GetStringAsync有加ConfigureAwait(false)，所以await接手的會是iocp thread，可以看到2.的訊息顯示沒有SynchronizationContext，所以第二個httpClient.GetStringAsync即使沒有加ConfigureAwait(false)，後續的code也不會是main thread (2.5)WPF123456789101112131415161718192021===== Current Thread Info (in TestStart method) ===== -- Worker threads: 0, Completion port threads: 0, Total threads: 20 SynchronizationContext: System.Windows.Threading.DispatcherSynchronizationContext ManagedThreadId: 1 IsThreadPoolThread: False===== Test 2.5 =====1. === Before httpClient.GetStringAsync === -- Worker threads: 0, Completion port threads: 0, Total threads: 20 SynchronizationContext: System.Windows.Threading.DispatcherSynchronizationContext ManagedThreadId: 1 IsThreadPoolThread: False2. === After httpClient.GetStringAsync ConfigureAwait(false) === -- Worker threads: 0, Completion port threads: 1, Total threads: 28 SynchronizationContext: ManagedThreadId: 12 IsThreadPoolThread: True3. === After httpClient.GetStringAsync === -- Worker threads: 0, Completion port threads: 1, Total threads: 28 SynchronizationContext: ManagedThreadId: 11 IsThreadPoolThread: True (2.5).NET Core Web API123456789101112131415161718192021===== Current Thread Info (in TestStart method) ===== -- Worker threads: 1, Completion port threads: 0, Total threads: 25 SynchronizationContext: ManagedThreadId: 10 IsThreadPoolThread: True===== Test 2.5 =====1. === Before httpClient.GetStringAsync === -- Worker threads: 1, Completion port threads: 0, Total threads: 25 SynchronizationContext: ManagedThreadId: 10 IsThreadPoolThread: True2. === After httpClient.GetStringAsync ConfigureAwait(false) === -- Worker threads: 0, Completion port threads: 1, Total threads: 30 SynchronizationContext: ManagedThreadId: 12 IsThreadPoolThread: True3. === After httpClient.GetStringAsync === -- Worker threads: 0, Completion port threads: 1, Total threads: 30 SynchronizationContext: ManagedThreadId: 12 IsThreadPoolThread: True (2.6)外面的沒加ConfigureAwait(false)，裡面的有加(2.6)程式碼C#12345678910111213141516171819202122232425private async Task RunTest2_6()&#123; Debug.WriteLine("===== Test 2.6 ====="); Debug.WriteLine("1. === Before MethodWithConfigureAwaitFalseInsideAsync ==="); PrintInfos(); await MethodWithConfigureAwaitFalseInsideAsync(); Debug.WriteLine("4. === After MethodWithConfigureAwaitFalseInsideAsync ==="); PrintInfos();&#125;private async Task&lt;string&gt; MethodWithConfigureAwaitFalseInsideAsync()&#123; Debug.WriteLine("2. === Before httpClient.GetStringAsync ConfigureAwait(false) ==="); PrintInfos(); var result = await httpClient.GetStringAsync(url).ConfigureAwait(false); Debug.WriteLine("3. === After httpClient.GetStringAsync ConfigureAwait(false) ==="); PrintInfos(); return result;&#125; (2.6)執行結果在外層WPF因為有SynchronizationContext所以await後續還是main thread，.NET Core沒有SynchronizationContext所以裡面最後是iocp thread，外層也是iocp thread繼續 (2.6)WPF1234567891011121314151617181920212223242526===== Current Thread Info (in TestStart method) ===== -- Worker threads: 0, Completion port threads: 0, Total threads: 19 SynchronizationContext: System.Windows.Threading.DispatcherSynchronizationContext ManagedThreadId: 1 IsThreadPoolThread: False===== Test 2.6 =====1. === Before MethodWithConfigureAwaitFalseInsideAsync === -- Worker threads: 0, Completion port threads: 0, Total threads: 19 SynchronizationContext: System.Windows.Threading.DispatcherSynchronizationContext ManagedThreadId: 1 IsThreadPoolThread: False2. === Before httpClient.GetStringAsync ConfigureAwait(false) === -- Worker threads: 0, Completion port threads: 0, Total threads: 19 SynchronizationContext: System.Windows.Threading.DispatcherSynchronizationContext ManagedThreadId: 1 IsThreadPoolThread: False3. === After httpClient.GetStringAsync ConfigureAwait(false) === -- Worker threads: 0, Completion port threads: 1, Total threads: 28 SynchronizationContext: ManagedThreadId: 11 IsThreadPoolThread: True4. === After MethodWithConfigureAwaitFalseInsideAsync === -- Worker threads: 0, Completion port threads: 1, Total threads: 28 SynchronizationContext: System.Windows.Threading.DispatcherSynchronizationContext ManagedThreadId: 1 IsThreadPoolThread: False (2.6).NET Core Web API1234567891011121314151617181920212223242526===== Current Thread Info (in TestStart method) ===== -- Worker threads: 1, Completion port threads: 0, Total threads: 29 SynchronizationContext: ManagedThreadId: 10 IsThreadPoolThread: True===== Test 2.6 =====1. === Before MethodWithConfigureAwaitFalseInsideAsync === -- Worker threads: 1, Completion port threads: 0, Total threads: 29 SynchronizationContext: ManagedThreadId: 10 IsThreadPoolThread: True2. === Before httpClient.GetStringAsync ConfigureAwait(false) === -- Worker threads: 1, Completion port threads: 0, Total threads: 29 SynchronizationContext: ManagedThreadId: 10 IsThreadPoolThread: True3. === After httpClient.GetStringAsync ConfigureAwait(false) === -- Worker threads: 0, Completion port threads: 1, Total threads: 30 SynchronizationContext: ManagedThreadId: 16 IsThreadPoolThread: True4. === After MethodWithConfigureAwaitFalseInsideAsync === -- Worker threads: 0, Completion port threads: 1, Total threads: 30 SynchronizationContext: ManagedThreadId: 16 IsThreadPoolThread: True (2.7)外面的有加ConfigureAwait(false)，裡面的沒加(2.7)程式碼C#12345678910111213141516171819202122232425private async Task RunTest2_7()&#123; Debug.WriteLine("===== Test 2.7 ====="); Debug.WriteLine("1. === Before MethodWithoutConfigureAwaitFalseInsideAsync ConfigureAwait(false) ==="); PrintInfos(); await MethodWithoutConfigureAwaitFalseInsideAsync().ConfigureAwait(false); Debug.WriteLine("4. === After MethodWithoutConfigureAwaitFalseInsideAsync ConfigureAwait(false) ==="); PrintInfos();&#125;private async Task&lt;string&gt; MethodWithoutConfigureAwaitFalseInsideAsync()&#123; Debug.WriteLine("2. === Before httpClient.GetStringAsync ==="); PrintInfos(); var result = await httpClient.GetStringAsync(url); Debug.WriteLine("3. === After httpClient.GetStringAsync ==="); PrintInfos(); return result;&#125; (2.7)執行結果WPF因為裡面的沒加ConfigureAwait(false)，所以await後續接手會是main thread，裡面最後執行完的是main thread，外層的有加ConfigureAwait(false)，不交由main thread執行ConfigureAwait(false)的後續，所以由worker thread接手 (2.7)WPF1234567891011121314151617181920212223242526===== Current Thread Info (in TestStart method) ===== -- Worker threads: 0, Completion port threads: 0, Total threads: 19 SynchronizationContext: System.Windows.Threading.DispatcherSynchronizationContext ManagedThreadId: 1 IsThreadPoolThread: False===== Test 2.7 =====1. === Before MethodWithoutConfigureAwaitFalseInsideAsync ConfigureAwait(false) === -- Worker threads: 0, Completion port threads: 0, Total threads: 19 SynchronizationContext: System.Windows.Threading.DispatcherSynchronizationContext ManagedThreadId: 1 IsThreadPoolThread: False2. === Before httpClient.GetStringAsync === -- Worker threads: 0, Completion port threads: 0, Total threads: 19 SynchronizationContext: System.Windows.Threading.DispatcherSynchronizationContext ManagedThreadId: 1 IsThreadPoolThread: False3. === After httpClient.GetStringAsync === -- Worker threads: 0, Completion port threads: 0, Total threads: 28 SynchronizationContext: System.Windows.Threading.DispatcherSynchronizationContext ManagedThreadId: 1 IsThreadPoolThread: False4. === After MethodWithoutConfigureAwaitFalseInsideAsync ConfigureAwait(false) === -- Worker threads: 1, Completion port threads: 0, Total threads: 28 SynchronizationContext: ManagedThreadId: 5 IsThreadPoolThread: True (2.7).NET Core Web API1234567891011121314151617181920212223242526===== Current Thread Info (in TestStart method) ===== -- Worker threads: 1, Completion port threads: 0, Total threads: 31 SynchronizationContext: ManagedThreadId: 9 IsThreadPoolThread: True===== Test 2.7 =====1. === Before MethodWithoutConfigureAwaitFalseInsideAsync ConfigureAwait(false) === -- Worker threads: 1, Completion port threads: 0, Total threads: 31 SynchronizationContext: ManagedThreadId: 9 IsThreadPoolThread: True2. === Before httpClient.GetStringAsync === -- Worker threads: 1, Completion port threads: 0, Total threads: 31 SynchronizationContext: ManagedThreadId: 9 IsThreadPoolThread: True3. === After httpClient.GetStringAsync === -- Worker threads: 0, Completion port threads: 1, Total threads: 32 SynchronizationContext: ManagedThreadId: 12 IsThreadPoolThread: True4. === After MethodWithoutConfigureAwaitFalseInsideAsync ConfigureAwait(false) === -- Worker threads: 0, Completion port threads: 1, Total threads: 32 SynchronizationContext: ManagedThreadId: 12 IsThreadPoolThread: True 測試三：承測試二，如果不跑在IO相關的task，而跑在Task.Delay上，後續執行緒是？(3.1)不加ConfigureAwait(false)(3.1)程式碼C#123456789101112private async Task RunTest3_1()&#123; Debug.WriteLine("===== Test 3.1 ====="); Debug.WriteLine("1. === Before Task.Delay ==="); PrintInfos(); await Task.Delay(1000); Debug.WriteLine("2. === After Task.Delay ==="); PrintInfos();&#125; (3.1)執行結果(3.1)WPF12345678910111213141516===== Current Thread Info (in TestStart method) ===== -- Worker threads: 0, Completion port threads: 0, Total threads: 18 SynchronizationContext: System.Windows.Threading.DispatcherSynchronizationContext ManagedThreadId: 1 IsThreadPoolThread: False===== Test 3.1 =====1. === Before Task.Delay === -- Worker threads: 0, Completion port threads: 0, Total threads: 18 SynchronizationContext: System.Windows.Threading.DispatcherSynchronizationContext ManagedThreadId: 1 IsThreadPoolThread: False2. === After Task.Delay === -- Worker threads: 0, Completion port threads: 0, Total threads: 20 SynchronizationContext: System.Windows.Threading.DispatcherSynchronizationContext ManagedThreadId: 1 IsThreadPoolThread: False (3.1).NET Core Web API12345678910111213141516===== Current Thread Info (in TestStart method) ===== -- Worker threads: 1, Completion port threads: 0, Total threads: 25 SynchronizationContext: ManagedThreadId: 10 IsThreadPoolThread: True===== Test 3.1 =====1. === Before Task.Delay === -- Worker threads: 1, Completion port threads: 0, Total threads: 25 SynchronizationContext: ManagedThreadId: 10 IsThreadPoolThread: True2. === After Task.Delay === -- Worker threads: 1, Completion port threads: 0, Total threads: 25 SynchronizationContext: ManagedThreadId: 10 IsThreadPoolThread: True (3.2)加ConfigureAwait(false)(3.2)程式碼C#123456789101112private async Task RunTest3_2()&#123; Debug.WriteLine("===== Test 3.2 ====="); Debug.WriteLine("1. === Before Task.Delay ConfigureAwait(false) ==="); PrintInfos(); await Task.Delay(1000).ConfigureAwait(false); Debug.WriteLine("2. === After Task.Delay ConfigureAwait(false) ==="); PrintInfos();&#125; (3.2)執行結果(3.2)WPF12345678910111213141516===== Current Thread Info (in TestStart method) ===== -- Worker threads: 0, Completion port threads: 0, Total threads: 19 SynchronizationContext: System.Windows.Threading.DispatcherSynchronizationContext ManagedThreadId: 1 IsThreadPoolThread: False===== Test 3.2 =====1. === Before Task.Delay ConfigureAwait(false) === -- Worker threads: 0, Completion port threads: 0, Total threads: 19 SynchronizationContext: System.Windows.Threading.DispatcherSynchronizationContext ManagedThreadId: 1 IsThreadPoolThread: False2. === After Task.Delay ConfigureAwait(false) === -- Worker threads: 1, Completion port threads: 0, Total threads: 21 SynchronizationContext: ManagedThreadId: 5 IsThreadPoolThread: True (3.2).NET Core Web API12345678910111213141516===== Current Thread Info (in TestStart method) ===== -- Worker threads: 1, Completion port threads: 0, Total threads: 25 SynchronizationContext: ManagedThreadId: 10 IsThreadPoolThread: True===== Test 3.2 =====1. === Before Task.Delay ConfigureAwait(false) === -- Worker threads: 1, Completion port threads: 0, Total threads: 25 SynchronizationContext: ManagedThreadId: 10 IsThreadPoolThread: True2. === After Task.Delay ConfigureAwait(false) === -- Worker threads: 1, Completion port threads: 0, Total threads: 25 SynchronizationContext: ManagedThreadId: 10 IsThreadPoolThread: True 程式碼source codecsharp-lab]]></content>
      <tags>
        <tag>C#</tag>
        <tag>async&amp;await</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[軟體開發建構筆記]]></title>
    <url>%2Fposts%2Fgeneral-software-development-process%2F</url>
    <content type="text"><![CDATA[紀錄一下軟體工程的每個專案／產品通常都會有以及應該要有的一些過程 mindset 價值優先，優先做有價值的／長期有複利效應的工作 早點雇用到好用的員工、新進員工能早點上手就是可能長期有複利效應的工作 如何快速迭代，fail fast 太晚跟客戶確認需求與實作出來的東西，方向錯了走的路都是浪費 需求文件／規格 User Story 模組功能 角色／使用權限 要蒐集／測量哪些資料，什麼樣的資料當指標可以很好的解釋市場／使用者行為 使用者行為的資料 維運需要的資料 畫面設計的準則 畫面／功能的等待時間 同時可服務人數 推播訊息，推播同時最大人數／頻率／即時性 服務的SLA，SLA的定義 專案管理 進度 怎麼追蹤feature/issue/bug，怎麼與版本控制的commit結合 怎麼分配ticket 設計文件 依照需求推算出的系統需求 系統架構 傳輸協定 程式碼開發環境 IDE 程式撰寫風格準則 套件檢查程式碼準則 版本控制 Git／SVN 程式碼存放處 版本控管的流程 Git Flow／其他設計 使用者介面端Web App 對RWD的要求 對不同瀏覽器的要求 對SEO的要求 對無障礙設計的要求 PWA SPA，優缺點，是否適用 JavaScript框架 CSS preprocessor 打包，壓縮，CDN i18n，l10n Mobile App 要支援的平台Android／iOS 平台的要支援版本 要用Native App／Hybrid App／還是其他產生App的方式開發 發佈，上架 伺服器端 HTTPS 選語言、框架、ORM 不同端點的傳輸協定TCP／UDP／MQTT等等 使用者註冊，驗證(authentication)，MFA，忘記密碼，session／JWT等等，OAuth，SSO RESTful API設計 API的即時文件，swagger 設計錯誤處理、API回應、log 是否已經要scale out load balance message queue接收事件 worker處理事件 行動端的推播訊息 i18n，l10n 資料庫端 哪些／多少資料要存SQL／NoSQL 哪些／多少資料要cache，cache策略 哪些資料要用index 哪些資料做正規化 哪些資料不做正規化 是否要scale out， 依需求考量CAP然後選適用的資料庫／服務 怎麼樣做對Machine Learning時資料比較好處理 CI/CD 檢查是否有不符合準則的程式碼 自動compile 自動測試 自動佈署 雲端 選平台AWS/GCP/Azure AI 整理資料 訓練模型 佈署 測試 單元測試 功能測試 整合測試 資安測試 OWASP 壓力測試 報表參考資料研究資料]]></content>
      <tags>
        <tag>Software Development</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Time Gem YouTube player]]></title>
    <url>%2Fposts%2Ftime-gem-youtube-player%2F</url>
    <content type="text"><![CDATA[我需要這樣的一個網頁的情況是，我本身在學習爵士鼓，有些時候老師會教一首歌怎麼打，但一開始肢體協調性以及對歌不夠熟悉，沒有辦法以歌曲的原速度跟著打鼓，所以會先用慢一點的速度，通常播放的情況是用手機的YouTube APP，而YouTube APP的速度調整只能以0.25倍為單位，我常用的是0.75倍或是1倍，但0.75倍到1倍有時候差太多，通常來說練習會以5~10個BPM慢慢往上加，所以打算寫一個靜態網頁，功能是貼上YouTube網址然後有幾個大按鈕方便手機使用，可以一點一點的加速、可以設定AB段循環。 已知可以控制瀏覽器影片播放器的速度用電腦的瀏覽器看YouTube即使調到2倍速有時候還是覺得速度很慢，所以會直接在console寫個JavaScript程式調到想要的速度，所以我應該可以在自己的網頁上用一個iframe把YouTube的影片嵌入在裡面，然後從自己的網頁上看怎麼控制嵌入在裡面的YouTube影片？ YouTube官方的嵌入影片播放器API查了一下，YouTube官方本身就有寫一個如果要嵌入YouTube影片可以用的library YouTube Player API Reference for iframe EmbedsYouTube Embedded Players and Player Parameters YouTube在桌面版瀏覽器上播放可以客製化播放速度弄到一半發現原來電腦版瀏覽器上播放速度可以0~2倍速度客製化，之前都直接按快捷鍵調整沒發現呵呵，但是手機板的APP還是沒有辦法小刻度的調，用手機的瀏覽器然後選擇電腦版的網頁就可以，不過用手機去操作桌面版很難用就是了。 如果YouTube的JavaScript library可以調iframe裡面的YouTube播放器速度，我應該也可以自己寫個JavaScript調iframe裡面的播放器速度？本來一開始因為自己的程式有bug，透過YouTube的library一直控制不到速度，想說乾脆自己從iframe裡面DOM裡面抓video控制影片速度，順便學到了因為會有資安問題所以不能這樣硬幹，網頁與內嵌iframe網頁的溝通方法，要靠Window.postMessage，簡單來說就是網頁透過postMessage把資料傳給內嵌網頁，內嵌網頁透過message event接收資料，用chrome的話可以用monitorEvents(window, &quot;message&quot;)在console來看兩邊溝通的log，以YouTube的情況來看，內嵌網頁會把可以呼叫的interface資訊提供給外面的網頁呼叫，只有他有定義的interface呼叫了有用。 成品Demo只是個小網站，所以沒有用上任何JS框架，也沒有用jQuery，直接用原生DOM API，CSS要針對HTML對應巢狀有點小亂所以後來用Sass寫，整體的layout沒有太複雜的邏輯所以沒有用上media query來做RWD，畫面元件設定最小寬高不要讓手機版手指不好按就好，整體都靠flex做layout。 有一些比較麻煩的地方反而是YouTube本身給的API不方便使用，要自己寫一些hack來解，像是沒有單獨的API可以直接告訴撥放器撥到哪裡就好，只有讀取並播放影片同時給起始與結束時間的API，但是呼叫那個API影片就又重新下載很浪費網路流量；像是有一個API可以load進影片，但是剛呼叫完就呼叫詢問影片長度的API可能因為還沒有載到影片meta data還沒有準備好所以呼叫失敗，只好自己寫一個setInterval去更新影片長度，有點多餘。 Time Gem YouTube player]]></content>
      <tags>
        <tag>Youtube IFrame API</tag>
        <tag>Youtube Player</tag>
        <tag>Drum tool</tag>
        <tag>Time Gem YouTube player</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[精準訂價閱讀筆記]]></title>
    <url>%2Fposts%2Fbook-note-confessions-of-the-pricing-man%2F</url>
    <content type="text"><![CDATA[個人的全書總結，整本書從不同面相探討訂價與獲利： 從訂價應以買家認知到的價值出發，訂出符合該價值的價格，但書中並不探討價值怎麼算成價格 從了解買家可能有的心理效應，賣家可以從中有更多獲利，書中探討多種不同的買家心理因素，蠻有趣的 從「總獲利 = (價格 * 銷量) - (變動成本+固定成本)」出發來討論訂價如何影響獲利，書中舉出很多例子，簡單的數學運算，蠻有趣 從理論上價格的調整會和銷量成反比的關係出發，鼓勵賣家找到最適當價格來最大化總獲利而不是營收，但如何知道價格與銷量將會呈什麼樣程度的反比並沒有太多解釋 整本書有些地方並沒有探討得太深，對訂價、控管獲利、行銷有興趣的我覺得可以讀。 買家心理寧可在價格上受騙，不要在品質上受騙價格太貴，隨著使用時間久了，負面感受可以消失，但是品質不好，用起來就感受一直不好 買家會把價格當做主要或唯一標準的情況買家對商品的真正品質感覺到不確定時，或面對一個完全不了解或很少購買的商品，比方說鎖頭，或是修理水電等等，這種情況可把產品組合重新配置，做出更高或更低的產品與價格差異 價格的定錨效應當買家沒有評估產品的知識或工具，各種來源的資訊就會變成買家心中價格的基準，如果賣家先介紹高價的商品，買家可能就會對各種功能大致要花費多少價格有較高的基準 中間價格同樣是發生在買家沒有評估產品的足夠知識或工具，有三種價格的情況，最低價的怕品質差，最高價又覺得可能超出需求導致花費過高，最後選擇中間價格的產品。如果本來只有賣50元與80元的產品，多賣一個120元的產品可能會導致原先可能選擇50元產品的買家改選擇80元產品，即使120元的產品銷量不一定很好，可能沒有直接的因銷量提升營收，但可能間接的提升了總體買家平均花費，沒有什麼人買的高價商品還是有其價值 提供額外的選擇提升銷售兩種產品組合：A： 甲產品 乙產品 10 15 兩種選擇的人數差不多 B： 甲產品 乙產品 甲+乙產品 10 15 15 大多數的人會選擇第三種選擇 用B的產品組合可以提升總體買家平均花費，而且實際上可能很多買家根本用不到乙產品 價格門檻與尾數9的說法有一種理論說，價格到一個數字過一個門檻即會影響銷量，而且通常是整數，為了最大化獲利，所以可能會有99.9元這種價格，還有一種說法是人的閱讀是從左至右，心理上對數字的感受愈右邊愈減弱，或是尾數是9已有特價或折扣的心理效應 展望理論同樣是得到100元與損失100元，心理上得到100元的效用可能是+1，但損失100元的效用可能是-3同樣的金額，信用卡會減少負效用的程度同樣的金額，75元用100元打75折可以減少負效用同樣的金額，$符號或元的放在價錢的最右邊或是不顯示，比較不意識到數字是價格，也有可能減少負效用同樣的金額，如果是在健身房，用年繳可能會比較便宜，但是按月繳可能會更有提醒自己繳錢的事實而提高使用率同樣的金額，現金回饋分月給的正效用可能比一年一次給的正效用高同樣的金額，不同的情境可能有不同的做法有最大效用 訂價策略同質產品中，一線品牌面對競爭對手的低價不以生產更便宜的產品，為降低公司內同質產品的互相競爭，通常會以另一個二線品牌來賣低價產品 低價成功因素一開始就低價、經營有效率、仍有一定且穩定品質、只關注核心需求提供必需品、高成長高營收、採購強、少負債、掌控更多的事情、廣告聚焦價格、清楚定位、成本優勢 高價成功因素優異的價值、客觀的高價值、高且穩定品質、廣告聚焦高價值（買家認知到的高價值才願意付出高價）、避免促銷 奢侈品成功因素所有面向最好的產品性能、品牌形象、有限的產量與市占率、嚴格避免折扣或類似行為（損害產品剩餘價值、品牌）、掌控價值鏈 價格影響獲利營收 = 價格 * 銷量，總獲利 = 營收-成本獲利三要素： 價格，銷量，成本 理論上假想價格與銷量是一條線，價格上升銷量下降，反之亦然最適當的價格，即是獲利最大的時候，也就是「價格 * 銷量 - 成本」最大的時候 降低價格期望銷售提升，要大量的提升才能維持獲利例：價格100元 * 銷量100萬 = 營收10,000萬元若變動成本（隨著賣出的產品數量會變動的成本，如原物料，假設為40元）40元 * 100萬 = 變動成本4,000萬元若固定成本（賣出多少個產品也不影響的成本，如店租）= 3,000萬元獲利 = 營收10,000萬元 - 變動成本4,000萬元 - 固定成本3,000萬元 = 3,000萬元 若價格降20%，100 * 20% = 80元，要維持一樣的獲利，要達到銷量x萬價格80元 * 銷量x萬 = 營收80x萬元變動成本一樣40元 * 銷量x萬 = 變動成本40x萬元固定成本一樣3,000萬元獲利要維持3,000萬元 = 營收80x萬元 - 變動成本40x萬元 - 固定成本3,000萬元40x = 6000, x = 150價格降20%銷量要增加50%，否則就是獲利下降重點要是獲利而不是營收 折扣提升出來的銷量要把不會買的變成會買，或是已經要買的買家買的更多才開始有意義比方說買一送一，萬一本來就有兩個人要買，變成兩個人合購比方說買家未來才打算買的東西，且不是經常性需要一直買的產品，像是汽車，因為折扣而提早買，就只是跟未來借銷量比方說該時段可能本身就不太會有買家，折價且沒有透過宣傳讓更多的人知道 囚犯理論與價格戰，各賣家的漲價與降價如果一方降價，另一方也降價，引發價格戰導致雙方獲利都下降如果一方漲價，另一方不漲價，可能導致銷售下降協商一同漲價通常是違法的漲價與降價，了解對手的反應非常重要，理想的狀況是提前發出公布訊息，表示漲價降價理由，或是表示是否會跟進對手的漲價或降價，嚇阻價格戰 訂價方式不理會產品價值與市場的自我訂價訂價 = 單看生產一個產品要多少成本 + 一定比例的獲利空間優點是方式簡單，如果競爭對手也這樣訂價，就會儘量避免價格戰影響獲利缺點是不理會買家認知的價值，有可能訂價太高或太低導致獲利不佳 損益兩平的銷量損益兩平的銷量 = 固定成本 / (價格 - 變動成本)可以算出銷量要到多少才開始賺錢去調整價格看銷量的變化，以及是否價格有可能達到這樣的銷量 組合訂價如果知道不同消費者在不同產品所願意付出的最高價格 消費者 葡萄酒 起司 葡萄酒+起司的組合 1 1 6 7 2 5 2 7 3 4 5 9 4 2.5 3 5.5 5 1.8 2.4 4.2 假設變動成本為0單看葡萄酒與起司，價格訂為葡萄酒4和起司5，消費者23會買葡萄酒，消費者13會買起司，獲利為4 * 2 + 5 * 2 = 18若只提供組合，價格訂為5.5，消費者1234會買組合，獲利5.5 * 4 = 22即使商品總價較低，但仍獲利較高若提供混合的訂價組合訂價5.5，葡萄酒4，起司2.4，消費者1234會買組合，消費者5會購買起司，總獲利22 + 2.4 = 24.4 分拆訂價仍可以考慮單獨賣一個商品就是一個市場的時候零組件標準化，顧客可以自行搭配例如機票把行李費拆開 不同數量不同訂價買家對產品數量的需求可能是第一個正效用最高，然後數量增加正效用遞減，依照不同數量最大化效用訂出買家仍願意購買的價格比如啤酒對買家產生的正效用，可能會隨著杯數減少、價格也可以愈多杯愈便宜，最大化總效用，最大化獲利，前提是不同買家不能彼此share啤酒就是了 按使用情況付費，賣服務，需求導向思維輪胎的例子，壽命延長了25%但是要在價格上漲25%非常困難卡車改按照使用的里程數收費，輪胎壽命延長了25%自然的就多收了25%的價格，可以鼓勵輪胎的進步，而使用者也只有使用的時候才付費，如果運輸需求低，不使用也就沒有費用 將免費的服務收費例子是免費使用的廁所，解決方案稱Sanifair，德國高速公路休息區原由政府負責，之後改民營Task &amp; Rast接下經營，將廁所翻新並收費0.5歐元，成人付全額才可通過一旋轉門，小孩及殘障人士會有一個代幣可免費進入，付的0.5歐元可得到一購物券，可以在休息區的各個地方使用，將免費來上廁所跟有買東西的人區隔出來，有買東西的人仍然算是可以免費上，之後價格變成了0.7歐元，0.5歐元的購物券 免費與增值的價格如skype、linkedin等，有免費的方案，也有premium的方案透過免費讓買家體驗產品，傳遞產品價值給買家： 要有吸引力的基本服務，帶來大量的用戶 免費跟升級有明確區隔 基本服務就很足夠會沒有人升級，基本服務不夠吸引人會沒有人來用 顧客導向訂價讓顧客自行表示願意購買的最高訂價但可能最後會有一堆不切實際的超低價，只能拿來清庫存但也有可能處理得好，就可以得知價格漲跌與銷量起伏的關係像是APP設定美金多少錢提醒，那銀行就可以知道匯率到多少的時候可能會有多少人買，如果銀行希望你買，甚至可以給個別的價格 拍賣有機會以買家最高的價格賣出，比方說ebay、google的廣告刊登競標]]></content>
      <tags>
        <tag>Reading</tag>
        <tag>Commerce</tag>
        <tag>Pricing</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小技巧分享與交流]]></title>
    <url>%2Fposts%2Ftrick-share-and-discuss%2F</url>
    <content type="text"><![CDATA[蒐集我常用的各種小工具與常用功能的快捷鍵，或是好像比較不為人知的一些小技巧，歡迎分享與交流。 Chrome瀏覽器1. 基本的快捷鍵 關閉分頁： ctrl + w 或 滑鼠中鍵點分頁 切換分頁： ctrl + tab（往右）、ctrl + shift + tab（往左） 開新分頁： ctrl + t 重新開啟最後關閉的分頁： ctrl + shift + t 開無痕視窗： ctrl + shift + n 用當前分頁網址再開一個新的分頁：alt + d 然後 alt + enter 或 滑鼠中鍵點重新整理的icon，基本上只要是網址都可以用滑鼠中鍵，上一頁、下一頁的icon以及書籤的資料夾（一次開多個書籤）都可以 2. 書籤整理有些常用到爆炸的網站像是：Google Map、字典等等的網站，在書籤上可以編輯名稱，不輸入名字，就會只留icon可以省書籤列空間，資料夾名稱也可以放emoji裝飾，下圖是我的Chrome書籤列XD 3. 開發人員工具DevTools(不知道怎麼開的上網查一下XD，我最常開的方法是按F12) 開Run command裡面有更多的功能可以用，快捷鍵： ctrl + shift + p 在Run command輸入screenshot會搜尋到四種截圖方式：選取部分畫面、全畫面擷取（包含網頁要往下滑才看的到的內容）、一個DOM節點的畫面擷取、當前顯示的畫面擷取 4. Debug 除了常用的在行數上面點一下會出現中斷點，在行數上面按右鍵可以新增conditional breakpoint、logpoint 有些時候用console.table()印資料來顯示比較方便 5. Chrome開發相關我平常追蹤的地方Google Chrome Developers Youtube Channel 6. 外掛 Streamkeys： 可以設定快捷鍵去操作瀏覽器正在播放的歌（Youtube、Spotify等等），有分成視窗切換到瀏覽器才有效的快捷鍵或是全局不用切換視窗只要有開著瀏覽器就有效的快捷鍵，我需要不用切換畫面就可以直接控制音樂，這樣做事做到一半要換歌或是暫停都不用滑鼠跟切畫面，我習慣用Spotify桌面板，但是桌面板快捷鍵要切換視窗才可以控制音樂，最後方法是用瀏覽器開一個Spotify的分頁，因為Spotify同一帳號不同設備之間都有連動，所以我用Streamkeys控制瀏覽器Spotify分頁的音樂，也會控制到桌面板的Spotify的音樂 Marinara: Pomodoro® Assistant： 如果你聽過番茄工作法，可以裝這個外掛來輔助，認真想要有效率要專注做事情或是學習的時候我會使用 Youtube平台1. 常用快捷鍵 全螢幕： f 倒帶30秒： j 快轉30秒： l 暫停： k 減速： shift + 靜音： m 字幕： shift + c 下一個影片： shift + n (next) 上一個影片： shift + p (previous) 2. 自訂影片速度youtube只提供0.75x跟1x速度，有時候放play-along的歌練習打鼓，但是一開始跟音樂太快的時候可以用這個方法更精細控制速度一點一點的從慢的練習到正常速度： 在瀏覽器DevTools的console裡面輸入 JavaScript12document.querySelector('video').playbackRate // 顯示現在撥放速度document.querySelector('video').playbackRate = 3 // 調整撥放速度為3倍速 Windows作業系統 ZoomIt：微軟官方出的放大螢幕小工具，簡報演講萬一要demo真的有什麼文件無法放大的時候可以用，也可以在螢幕當白板寫字 PicPick：主要是截圖軟體，可以有多種截圖的方式，也可以在螢幕當白板寫字 在任一資料夾下，在資料夾路徑輸入cmd可以直接開啟一個command line interface，路徑就是剛才資料夾的路徑，不過權限不是管理員 Visual Studio Code外掛 Zoom放大縮小快捷鍵：ctrl + = （放大）、ctrl + - （縮小） Emmet in Visual Studio Code（以前叫Zencoding）：Visual Studio Code已內建，有很多簡便的功能，最基本的像是multi cursor可以按住alt+滑鼠一次多個游標編輯多個地方 Live Server：如果要編輯html可以直接有一個Go Live按鈕幫你開一個local server即時顯示 Bracket Pair Colorizer：幫你把誇號、大誇號同一組用同樣的顏色，不然誇號一連串的話看到眼睛快花了 Markdown All in One、Markdown Preview Github、markdownlint：我個人寫markdown有用 Google Search關鍵字我最常用的是完全符合關鍵字的「&quot;keyword&quot;」和包含網站「site:xxxx.com」以及排除網站「-site:xxxx.com」]]></content>
      <tags>
        <tag>Tricks</tag>
        <tag>Chrome Tricks</tag>
        <tag>Chrome DevTools Tricks</tag>
        <tag>Chrome Plugin</tag>
        <tag>Visual Studio Plugin</tag>
        <tag>YouTube Tricks</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C#的Async & Await筆記]]></title>
    <url>%2Fposts%2Fcsharp-async-await-note%2F</url>
    <content type="text"><![CDATA[最一開始學習C#的時候，搞不太清楚async/await實際上到底發生什麼事，有些人認為用await就是新增一個執行緒去執行一個async method，用多執行緒來平行處理的概念，但是又看到一般建議如果有用到async/await，最好就是all the way都用async/await，不要中間又用Task.Result等等不是await的方式，如果真的每寫一個await就是新增一條執行緒去執行，那all the way都是await不就占用超多條執行緒？ 當時沒有辦法有其他方式理解async/await，只能照著建議的使用方式去寫程式，想深入了解async/await但常常看不懂，看文件上寫CPU bound與IO bound的情況，沒有辦法真的理解情況的不同會怎麼影響執行與效能，看到文件上寫碰到await會跳回到呼叫端，等await裡面的東西結束了就會從await下方自動繼續往下執行，腦袋裡的模型暫時只能想像常常都是有一個執行緒被拿去執行await裡面的東西。 之後念了一些作業系統的概念，再查一次資料，回來重新理解async/await，發現以前腦袋裡那些暫時先那樣想的模型，有些可以說是對的也可以說不完全對，async/await的題目有很多東西可以研究，在這邊來做一點筆記，有錯誤還請指正。 TL;DR，細節懶得看只想先知道怎麼做下一篇C#的Async &amp; Await筆記(2)有程式碼可以玩玩看 平行執行Task 多個MethodAsync呼叫可以先持有各method回傳的Task，做其他事情，然後真正需要倚賴Task的結果時再用await依據結果繼續執行。 不要用async void 沒真的需要用await，可以不用return await MethodAsync(...)，直接傳回給呼叫端Task 寫CPU bound的library API，讓呼叫方自行決定怎麼控制執行緒來執行 寫library除非一定需要跟UI thread互動，否則建議使用await時加上ConfigureAwait(false) 非同步處理是一個目的，多執行緒是一種達成方式，但不是唯一的達成方式。用await執行IO bound的method，IO等待期間沒有執行緒被占用著等待IO，async/await本身也不額外新增執行緒 1. 平行執行Task當持有回傳的Task時，實際上Task的內容已經開始執行。可以的話先開始執行耗時的async method，再執行其他不倚賴剛才async method結果的運算，一定需要async method的結果時再用await。 C#1234567// 下面這一行會建立並開始一個Taskvar myTask = someWebAccessMethodAsync(url);// 當Task執行期間，可以先做其他不依賴Task結果的事情...// 當前method會停止並跳回給呼叫端，await之後的程式會在Task完成以後繼續被執行var result = await myTask; 有多個async method先取得各個Task，如此各個async method即開始處理，在需要結果的時候再用await。 C#12345678910111213Task&lt;int&gt; download1 = ProcessURLAsync("https://msdn.microsoft.com", client);Task&lt;int&gt; download2 = ProcessURLAsync("https://msdn.microsoft.com/library/hh156528(VS.110).aspx", client); Task&lt;int&gt; download3 = ProcessURLAsync("https://msdn.microsoft.com/library/67w7t67f.aspx", client); // 需要個別Task的結果再依序用awaitint length1 = await download1; int length2 = await download2; int length3 = await download3; 參考How to: Make Multiple Web Requests in Parallel by Using async and await (C#) 2. 不要用async void除非是最上層的event handler需要，否則不要用async void。 呼叫端沒辦法知道async method什麼時候工作結束，可能導致race condition，下面案例line A和line B被執行到的順序不一定，有可能經過了2秒line B還沒完成，line A就先往下印出m_GetResponse。 C#1234567891011121314151617private async void Button1_Click(object Sender, EventArgs e) &#123; try &#123; SendData("https://secure.flickr.com/services/oauth/request_token"); await Task.Delay(2000);// line A, race condition with line B DebugPrint("Received Data: " + m_GetResponse); &#125; catch (Exception ex) &#123; rootPage.NotifyUser("Error posting data to server." + ex.Message); &#125;&#125;private async void SendData(string Url) &#123; var request = WebRequest.Create(Url); using (var response = await request.GetResponseAsync()) // line B, race condition with line A using (var stream = new StreamReader(response.GetResponseStream())) m_GetResponse = stream.ReadToEnd();&#125; async void會fire and forget，預期的try/catch會抓不到exception。 C#123456789101112131415161718192021private async void Button1_Click(object Sender, EventArgs e) &#123; try &#123; SendData("https://secure.flickr.com/services/oauth/request_token"); //await Task.Delay(2000); //DebugPrint("Received Data: " + m_GetResponse); &#125; catch (Exception ex) &#123; // 有可能抓不到SendData丟出來的exception // 因為等SendData裡面的await後續開始執行時 // main thread可能已經執行完整個Button1_Click // 最後exception可能會是更外層才接到然後跳到螢幕上顯示 rootPage.NotifyUser("Error posting data to server." + ex.Message); &#125;&#125;private async void SendData(string Url) &#123; var request = WebRequest.Create(Url); using (var response = await request.GetResponseAsync()) using (var stream = new StreamReader(response.GetResponseStream())) m_GetResponse = stream.ReadToEnd();&#125; 上述程式比較好的寫法 C#1234567891011121314151617private async void Button1_Click(object Sender, EventArgs e) &#123; try &#123; m_GetResponse = await SendDataAsync("https://secure.flickr.com/services/oauth/request_token"); DebugPrint("Received Data: " + m_GetResponse); &#125; catch (Exception ex) &#123; rootPage.NotifyUser("Error posting data to server." + ex.Message); &#125;&#125;private async Task&lt;string&gt; SendDataAsync(string Url) &#123; var request = WebRequest.Create(Url); using (var response = await request.GetResponseAsync()) using (var stream = new StreamReader(response.GetResponseStream())) return stream.ReadToEnd();&#125; 參考Tip 1: Async void is for top-level event-handlers only 3. 沒真的需要用await，可以不用return await MethodAsync(...)，直接傳回給呼叫端TaskC#123456789// 多餘的async和awaitpublic async Task&lt;string&gt; Method(...) &#123; // 中間做一些不用await的事 return await IORequestAsync(...);&#125;// 不用掛上async，直接回傳Task就可以了public Task&lt;string&gt; Method(...) &#123; return IORequestAsync(...);&#125; 4. 寫CPU bound的library API，讓呼叫方自行決定怎麼控制執行緒來執行比方說要寫的API需要做大量Deserialize，或是很多需要計算的for迴圈，CPU bound，這時候讓呼叫API的地方自行決定該怎麼控制多少執行緒來執行，不要包起來默默的占用執行緒。 參考Tip 2: Distinguish CPU-Bound work from IO-bound work 5. 寫library除非需要跟UI thread互動，否則建議使用await時加上ConfigureAwait(false)一般有UI thread的應用程式，因為使用SynchronizationContext機制的原因，所以在await的Task完成之後，機制上會把剩下要執行的部分用SynchroniztionContext.Post的方式（把要做的事情包起來丟到一個queue，UI thread會去把這個queue裡的工作做掉）丟給UI thread去執行，容易導致UI thread執行太多不必要的工作，導致UI thread被佔用畫面卡住，所以建議用await的地方加上ConfigureAwait(false)讓await的Task完成後，不要透過SynchronizationContext的機制執行後續的程式，而透過執行緒池裡的執行緒完成。 6. 非同步是一個目的，多執行緒是一種達成方式，但不是唯一的達成方式。用await執行IO bound的method，IO等待期間沒有執行緒被占用著等待IO，async/await本身也不額外新增執行緒先知道兩點： 一般硬體／作業系統有機制可以不用只靠執行緒一直問IO是否完成了來知道IO狀態，而是當IO完成了來通知process該IO已經完成了。 thread pool裡面有worker thread、IOCP thread兩種。 從上層一點來說，當呼叫了一個IO操作，會取得一個Task，此時IO已經開始執行，當執行到await task，如果Task還沒完成，當前執行緒會跳回到caller端，如果Task已經完成，則會直接繼續執行。 await後續還未完成的部分，會在實際IO結束完成後，透過IOCP(Input Output Completion Port)的機制，由IOCP thread來接手，如果是有SynchronizationContext(通常有UI的像是WinForm, WPF都有)，會以SynchroniztionContext.Post的方式丟給UI thread去執行await後續的程式，如果有加上ConfigureAwait(false)則由當前IOCP thread繼續執行。 compiler在compile的時候看到await實際上有做一些手腳，程式執行到await這邊會先去看Task是不是已經完成了（fast path優化），如果已經完成了則沒必要透過額外的await機制增加負擔，而是直接繼續執行就可以了，所以程式碼上await後續執行的thread也是有可能是原先的thread，還有些情況像是做測試就可以用Task.FromResult直接給一個完成了的Task可以省去額外的await負擔。 非同步是一個目的，多執行緒是一種達成方式，但不是唯一的達成方式。過程中主執行緒在IO等待期間沒有閒置也一直繼續執行不倚賴IO結果的程式，而當IO完成了，await後續的程式是由thread pool裡面的IOCP thread來接手，沒有執行緒空等，過程中沒有額外的新增執行緒，全靠原本thread pool的機制在管理執行緒數量。不依賴IO結果的程式與等待IO兩件工作非同步的在進行。 參考Lucian Wischik - Async Part 1 — new feature in Visual Studio 11 for responsive programming.There Is No Thread 小記IOCP一個專門用來處理同時有多個IO的Asynchronous I/O機制，裡面主要有一個I/O Completion Queue以FIFO存放完成了的IO工作相關資訊（包含IO本身資訊，以及要繼續執行的程式），有一個WaitingThread List以LIFO存放執行緒（一個執行緒執行完一個工作要再執行下一個工作，LIFO有機會因省去context switch而速度加快）。 應用端呼叫IO時附上操作IO的資訊以及IO完成後要怎麼處理的資訊，當IO完成後這些資訊就會被放到I/O Completion Queue，然後會有一定數量的IOCP thread去處理這些完成了的IO工作。以往常常是一個thread來處理一個IO，有很多個IO request就要很多個thread，而現在是多個thread去檢查一個存放完成了IO的queue，如果沒有要處理的IO在I/O Completion Queue裡面，thread就會被block住放進WaitingThread List，等I/O Completion Queue又有IO完成了的資訊，再以LIFO的方式從WaitingThread List取出thread喚醒來工作。 參考Asynchronous I/OIOCP工作者线程（worker thread）和I/O线程I/O Completion Ports 全部參考C# async &amp; await，我覺得這些資料都解釋的很好很值得一讀： How to: Make Multiple Web Requests in Parallel by Using async and await (C#) Six Essential Tips for Async Tip 1: Async void is for top-level event-handlers only Tip 2: Distinguish CPU-Bound work from IO-bound work Lucian Wischik - Async Part 1 — new feature in Visual Studio 11 for responsive programming. Lucian Wischik - Async Part 2 — deep dive into the new language feature of VB/C# 談C# 編譯器編譯前的程式碼擴展行為 (2017年續 上) IOCP相關： Asynchronous I/O IOCP 工作者线程（worker thread）和I/O线程 I/O Completion Ports]]></content>
      <tags>
        <tag>C#</tag>
        <tag>async&amp;await</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Conceptual Problems/Solutions on Leetcode]]></title>
    <url>%2Fposts%2Fconceptual-problems-solutions-on-leetcode%2F</url>
    <content type="text"><![CDATA[This article is for helping someone who wants to practice algorithms on leetcode, and already has some basic data structure knowledge like hash table, stack, queue, etc. After solving some problems, I think some conceptual problems/solutions that once are understood, other problems are just the same. And without knowing these solutions, some problems are just not so easy to come up with a good solution. Frequently Used Coding Tips, General Templates &amp; Ideas1. getting a bigger/smaller numberinstead of using if/else: 123// C#Math.Max(a, b)Math.Min(a, b) 123# Pythonmax(a, b)min(a, b) 2. check if two variables are nullIf a or b is null, return false.If both of them are null, return true.Otherwise continue.This snippet of code is so concise and beautiful, it gets rid of so much if/else. 1234// C#if(a == null || b == null) &#123; return a == b;&#125; 123# Pythonif a is None or b is None: return a == b 3. BFS(Breath First Search) template12345678// C#Queue&lt;int&gt; queue = new Queue&lt;int&gt;(); // choose Stack or Queue base on the problemwhile(queue.Count != 0) &#123; int levelSize = queue.Count; while(levelSize-- &gt; 0) &#123; // do something like enqueue, dequeue... &#125;&#125; 1234567891011121314151617# Python# choose Stack or Queue base on the problemfrom collections import dequequeue = deque()while len(queue) != 0: level_size = len(queue) while level_size &gt; 0: # queue.append(x), queue.popleft() level_size -= 1stack = []while len(stack) != 0: level_size = len(stack) while level_size &gt; 0: # stack.pop(), stack.append(x) level_size -= 1 4. binary tree solution templateWhen visiting a node, usually there are three things we can do, base on the problem to design the order of steps. visit a node, do something(like adding the node&#39;s value into the result collection) visit the left child node visit the right child node 5. iterate an array over and over againIterate each item in an array from start to end again and again without worrying the index out of bound problem at the end of the array. 123// C#index = (index + 1) % length;index = (index + length - 1) % length; // iterate from end to start 1234# Pythonlength = len(arr)index = (index + 1) % lengthindex = (index + length - 1) % length; # iterate from end to start 6. sorted dataSearching for something and the data is sorted or some math problem which is from 1 to N. Binary Search! 7. int overflow in binary searchAvoid integer overflow when adding two large integer in binary search 1234567// C#// don't do this when left + right will overflowmid = (left + right) / 2// do thismid = left + (right - left) / 2// proof:// mid = (left + right) / 2 = left / 2 + right / 2 = left - left / 2 + right / 2 = left + (right - left) / 2 8. recusive solution might not be space complexity O(1)In the Discuss page of the problem, some solution&#39;s code might looks concise by using recursion, but keep in mind that the stack takes memory space still, so usually the space complexity is not O(1). Bit Manupliation191. Number of 1 Bits1234567891011121314// C#// The basic solution is to iterate over bits by bit shifting (n &gt;&gt; 1) then check if rightmost bit is one (n &amp; 1).// The trick here is that n &amp; (n - 1) can eliminate the rightmost 1 in the n's binary bits, so it doesn't have to iterate all bits of n.// Now the time complexity is depends on how many of 1 in n, not how many bits of n.public class Solution &#123; public int HammingWeight(uint n) &#123; int count = 0; while(n != 0) &#123; n = n &amp; (n - 1); count++; &#125; return count; &#125;&#125; 12345678# Pythonclass Solution: def hammingWeight(self, n: int) -&gt; int: count = 0 while n != 0: n = n &amp; (n - 1) count += 1 return count Array448. Find All Numbers Disappeared in an Array1234567891011121314151617181920// C#// If modifying the iput array is allowed, we can use some trick to manipulate the array to solve some problem without extra space.// Like using positive/negative in the array to mark visitedpublic class Solution &#123; public IList&lt;int&gt; FindDisappearedNumbers(int[] nums) &#123; for(int i = 0; i &lt; nums.Length; i++) &#123; int index = Math.Abs(nums[i]) - 1; if(nums[index] &gt; 0) &#123; nums[index] = -nums[index]; &#125; &#125; IList&lt;int&gt; result = new List&lt;int&gt;(); for(int i = 0; i &lt; nums.Length; i++) &#123; if(nums[i] &gt; 0) &#123; result.Add(i + 1); &#125; &#125; return result; &#125;&#125; 12345678910111213# Pythonclass Solution: def findDisappearedNumbers(self, nums: List[int]) -&gt; List[int]: for i in range(0, len(nums)): index = abs(nums[i]) - 1 if nums[index] &gt; 0: nums[index] = -nums[index] result = [] for i in range(0, len(nums)): if nums[i] &gt; 0: result.append(i + 1) return result Key/Value1. Two Sum123456789101112131415// C#// using key as distance to target, finding if there is a num equals to the distance to targetpublic class Solution &#123; public int[] TwoSum(int[] nums, int target) &#123; Dictionary&lt;int , int&gt; dict = new Dictionary&lt;int, int&gt;(); for(int i = 0; i &lt; nums.Length; i++) &#123; if(dict.ContainsKey(nums[i])) &#123; return new int[]&#123;dict[nums[i]], i&#125;; &#125; else &#123; dict[target - nums[i]] = i; &#125; &#125; return new int[2]; &#125;&#125; 123456789class Solution: def twoSum(self, nums: List[int], target: int) -&gt; List[int]: dict = &#123;&#125; for (i, num) in enumerate(nums): if num in dict: return [dict[num], i] else: dict[target - num] = i return [] Binary Search704. Binary Search123456789101112131415161718// C#public class Solution &#123; public int Search(int[] nums, int target) &#123; int n = nums.Length; if(n == 0) return -1; int left = 0; int right = n - 1; while(left &lt;= right)&#123; int mid = left + (right - left) / 2; if(nums[mid] &lt; target) left = mid + 1; else if (nums[mid] == target) return mid; else right = mid - 1; &#125; return -1; &#125;&#125; 12345678910class Solution: def search(self, nums: List[int], target: int) -&gt; int: left, right = 0, len(nums) - 1 while left &lt;= right: mid = left + (right - left) // 2 num = nums[mid] if num == target: return mid elif num &gt; target: right = mid - 1 else: left = mid + 1 return -1 744. Find Smallest Letter Greater Than Target1234567891011121314151617// C#public class Solution &#123; public char NextGreatestLetter(char[] letters, char target) &#123; int n = letters.Length; if(target &gt;= letters[n - 1]) return letters[0]; int left = 0; int right = n - 1; while(left &lt; right)&#123; int mid = left + (right - left) / 2; if(letters[mid] &lt;= target) left = mid + 1; else right = mid; &#125; return letters[right]; &#125;&#125; 12345678910class Solution: def nextGreatestLetter(self, letters: List[str], target: str) -&gt; str: left, right = 0, len(letters) - 1 if target &gt;= letters[right]: return letters[0] while left &lt; right: mid = left + (right - left) // 2 if letters[mid] &lt;= target: left = mid + 1 else: right = mid return letters[right] Breath First Search111. Minimum Depth of Binary Tree12345678910111213141516171819202122// C#public class Solution &#123; public int MinDepth(TreeNode root) &#123; if(root == null) return 0; int currDepth = 0; Queue&lt;TreeNode&gt; nodes = new Queue&lt;TreeNode&gt;(); nodes.Enqueue(root); while(nodes.Count != 0) &#123; int levelSize = nodes.Count; currDepth++; while(levelSize-- &gt; 0) &#123; TreeNode node = nodes.Dequeue(); if(node.left == null &amp;&amp; node.right == null) &#123; return currDepth; &#125; if(node.left != null) nodes.Enqueue(node.left); if(node.right != null) nodes.Enqueue(node.right); &#125; &#125; return currDepth; &#125;&#125; 12345678910111213141516171819202122232425262728# Definition for a binary tree node.# class TreeNode:# def __init__(self, val=0, left=None, right=None):# self.val = val# self.left = left# self.right = rightfrom collections import dequeclass Solution: def minDepth(self, root: Optional[TreeNode]) -&gt; int: if root is None: return 0 curr_depth = 0 nodes = deque() nodes.append(root) while len(nodes) != 0: level_size = len(nodes) curr_depth += 1 for i in range(level_size): node = nodes.popleft() if node: if node.left is None and node.right is None: return curr_depth nodes.append(node.left) nodes.append(node.right) return curr_depth Linked List83. Remove Duplicates from Sorted List1234567891011121314151617// C#public class Solution &#123; public ListNode DeleteDuplicates(ListNode head) &#123; if(head == null) return head; ListNode curr = head; while(curr.next != null) &#123; if(curr.val == curr.next.val) &#123; curr.next = curr.next.next; &#125; else &#123; curr = curr.next; &#125; &#125; return head; &#125;&#125; 1234567891011121314151617# Definition for singly-linked list.# class ListNode:# def __init__(self, val=0, next=None):# self.val = val# self.next = nextclass Solution: def deleteDuplicates(self, head: Optional[ListNode]) -&gt; Optional[ListNode]: if head is None: return head curr = head while curr.next: if curr.val == curr.next.val: curr.next = curr.next.next else: curr = curr.next return head 141. Linked List Cycle1234567891011121314151617181920// C#// Floyd's Tortoise and Harepublic class Solution &#123; public bool HasCycle(ListNode head) &#123; if (head == null || head.next == null) &#123; return false; &#125; ListNode slow = head; ListNode fast = head.next; while(slow != fast) &#123; if(fast == null || fast.next == null) &#123; return false; &#125; slow = slow.next; fast = fast.next.next; &#125; return true; &#125;&#125; 1234567891011121314151617181920# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def hasCycle(self, head: Optional[ListNode]) -&gt; bool: if head is None or head.next is None: return False slow = head fast = head.next while slow != fast: if fast is None or fast.next is None: return False slow = slow.next fast = fast.next.next return True 142. Linked List Cycle IIUsing Floyd&#39;s cycle detection algoritm to solve this problem only takes O(1) space complexity.Why Floyd&#39;s cycle detection algorithm works? Detecting loop in a linked list. 12345678910111213141516171819202122// C#public class Solution &#123; public ListNode DetectCycle(ListNode head) &#123; if (head == null) return null; ListNode slow = head; ListNode fast = head; while(fast != null &amp;&amp; fast.next != null) &#123; slow = slow.next; fast = fast.next.next; if(slow == fast) &#123; fast = head; while(slow != fast) &#123; slow = slow.next; fast = fast.next; &#125; return fast; &#125; &#125; return null; &#125;&#125; 123456789101112131415161718192021222324# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def detectCycle(self, head: ListNode) -&gt; ListNode: if head is None or head.next is None: return None slow = head fast = head while fast is not None and fast.next is not None: slow = slow.next fast = fast.next.next if slow == fast: fast = head while slow != fast: slow = slow.next fast = fast.next return fast return None 203. Remove Linked List Elements1234567891011121314151617// C#// using a dummy head to eliminate those null edge casespublic class Solution &#123; public ListNode RemoveElements(ListNode head, int val) &#123; ListNode dummy = new ListNode(0); dummy.next = head; ListNode curr = dummy; while(curr != null &amp;&amp; curr.next != null) &#123; if(curr.next.val == val) &#123; curr.next = curr.next.next; &#125; else &#123; curr = curr.next; &#125; &#125; return dummy.next; &#125;&#125; 1234567891011121314151617# Definition for singly-linked list.# class ListNode:# def __init__(self, val=0, next=None):# self.val = val# self.next = nextclass Solution: def removeElements(self, head: Optional[ListNode], val: int) -&gt; Optional[ListNode]: dummy_head = ListNode(0) dummy_head.next = head curr = dummy_head while curr is not None and curr.next is not None: if curr.next.val == val: curr.next = curr.next.next else: curr = curr.next return dummy_head.next 206. Reverse Linked List1234567891011121314// C#public class Solution &#123; public ListNode ReverseList(ListNode head) &#123; ListNode prev = null; ListNode curr = head; while(curr != null) &#123; ListNode temp = curr.next; curr.next = prev; prev = curr; curr = temp; &#125; return prev; &#125;&#125; 123456789101112131415# Definition for singly-linked list.# class ListNode:# def __init__(self, val=0, next=None):# self.val = val# self.next = nextclass Solution: def reverseList(self, head: Optional[ListNode]) -&gt; Optional[ListNode]: prev = None curr = head while curr is not None: temp = curr.next curr.next = prev prev = curr curr = temp return prev Sliding WindowSliding Window algorithm template to solve all the Leetcode substring search problem. 438. Find All Anagrams in a String567. Permutation in StringPrefix Sum560. Subarray Sum Equals K437. Path Sum IIIPermutation, Backtrackingbacktracking solution template46. Permutations123456789101112131415161718192021222324252627282930// C#public class Solution &#123; public IList&lt;IList&lt;int&gt;&gt; Permute(int[] nums) &#123; IList&lt;IList&lt;int&gt;&gt; result = new List&lt;IList&lt;int&gt;&gt;(); // for some problems, it might be good to sort first backtracking(nums, 0, result); return result; &#125; private void backtracking(int[] nums, int startIndex, IList&lt;IList&lt;int&gt;&gt; result) &#123; if(startIndex == nums.Length - 1) &#123; result.Add(new List&lt;int&gt;(nums)); return; &#125; for(int i = startIndex; i &lt; nums.Length; i++) &#123; // some method to mark the current index is visited swap(nums, startIndex, i); backtracking(nums, startIndex + 1, result); // some method to erase the current index is visited swap(nums, startIndex, i); &#125; &#125; private void swap(int[] nums, int indexA, int indexB) &#123; int temp = nums[indexA]; nums[indexA] = nums[indexB]; nums[indexB] = temp; &#125;&#125; 1234567891011121314151617181920class Solution: def permute(self, nums: List[int]) -&gt; List[List[int]]: result = [] self.backtracking(nums, 0, result) return result def backtracking(self, nums: List[int], start_index: int, result: List[List[int]]): if start_index == len(nums): result.append(list(nums)) return for i in range(start_index, len(nums)): self.swap(nums, start_index, i) self.backtracking(nums, start_index + 1, result) self.swap(nums, start_index, i) def swap(self, nums: List[int], index_a: int, index_b: int): temp = nums[index_a] nums[index_a] = nums[index_b] nums[index_b] = temp 1079. Letter Tile Possibilities784. Letter Case PermutationDynamic Programming746. Min Cost Climbing Stairs53. Maximum Subarray121. Best Time to Buy and Sell Stock303. Range Sum Query - Immutable123456789101112131415161718// C#// save every range from index 0 to index j// sum from index i to index j = range(0, j) - range(0, i)public class NumArray &#123; private int[] ranges; public NumArray(int[] nums) &#123; ranges = new int[nums.Length + 1]; int sum = 0; for(int i = 0; i &lt; nums.Length; i++) &#123; ranges[i + 1] = sum + nums[i]; sum += nums[i]; &#125; &#125; public int SumRange(int i, int j) &#123; return ranges[j + 1] - ranges[i]; &#125;&#125; 12345678910111213141516class NumArray: def __init__(self, nums: List[int]): self.__ranges = [0] sum = 0 for (i, num) in enumerate(nums): self.__ranges.append(sum + num) sum += num def sumRange(self, left: int, right: int) -&gt; int: return self.__ranges[right + 1] - self.__ranges[left]# Your NumArray object will be instantiated and called as such:# obj = NumArray(nums)# param_1 = obj.sumRange(left,right) 413. Arithmetic SlicesUnion Find547. Friend CirclesJava solution, Union Find]]></content>
      <tags>
        <tag>Algorithms</tag>
        <tag>Leetcode</tag>
        <tag>Conceptual Problems</tag>
        <tag>Coding Tips</tag>
        <tag>Code Templates</tag>
      </tags>
  </entry>
</search>
